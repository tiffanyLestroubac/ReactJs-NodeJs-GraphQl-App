import { createElement, Children, Component } from 'react';
import { findDOMNode } from 'react-dom';

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var Slide = function Slide(_ref) {
  var _ref$basis = _ref.basis,
      basis = _ref$basis === void 0 ? '100%' : _ref$basis,
      _ref$gutter = _ref.gutter,
      gutter = _ref$gutter === void 0 ? '1em' : _ref$gutter,
      _ref$className = _ref.className,
      className = _ref$className === void 0 ? '' : _ref$className,
      children = _ref.children,
      props = _objectWithoutProperties(_ref, ["basis", "gutter", "className", "children"]);

  return /*#__PURE__*/createElement("div", _extends({
    className: className,
    style: {
      flex: '0 0 auto',
      width: basis,
      marginLeft: gutter
    }
  }, props), children);
};

var includes = function includes(val, arr) {
  return arr.includes ? arr.includes(val) : !!arr.filter(function (item) {
    return item === val;
  }).length;
};

var wrapAroundValue = function wrapAroundValue(val, max) {
  return (val % max + max) % max;
};

var hardBoundedValue = function hardBoundedValue(val, max) {
  return Math.max(0, Math.min(max, val));
};

var normalizeIndex = function normalizeIndex(idx, len) {
  var wrap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  return wrap ? wrapAroundValue(idx, len) : hardBoundedValue(idx, len - 1);
};
var values = Object.values || function (obj) {
  return Object.keys(obj).map(function (key) {
    return obj[key];
  });
};
var noop = function noop() {};
var easeOutQuint = function easeOutQuint(t) {
  var n = t;
  return 1 + --n * Math.pow(n, 4);
};
var on = function on(evt) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  return function (cb) {
    return function (el) {
      if (el && typeof el.addEventListener === 'function') {
        el.addEventListener(evt, cb, opts);
        return function () {
          return el.removeEventListener(evt, cb);
        };
      }
    };
  };
};
var onWindowScroll = function onWindowScroll(cb) {
  return on('scroll', true)(cb)(window);
};
var onScroll = function onScroll(cb) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$target = _ref.target,
      target = _ref$target === void 0 ? window : _ref$target;

  return onWindowScroll(function (e) {
    return (target === window || target === e.target) && cb(e);
  });
};
var onScrollEnd = function onScrollEnd(cb) {
  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref2$wait = _ref2.wait,
      wait = _ref2$wait === void 0 ? 100 : _ref2$wait,
      _ref2$target = _ref2.target,
      target = _ref2$target === void 0 ? window : _ref2$target;

  return function (timeoutID) {
    return onScroll(function (evt) {
      clearTimeout(timeoutID);
      timeoutID = setTimeout(function () {
        return evt.target === target ? cb() : undefined;
      }, wait);
    });
  }(0);
};
var onScrollStart = function onScrollStart(cb) {
  var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref3$target = _ref3.target,
      target = _ref3$target === void 0 ? window : _ref3$target;

  var started = false;
  var offScrollEnd = onScrollEnd(function () {
    started = false;
  }, {
    target: target
  });
  var offScroll = onScroll(function (e) {
    if (!started) {
      started = true;
      cb(e);
    }
  }, {
    target: target
  });
  return function () {
    if (typeof offScroll === 'function') {
      offScroll();
    }

    if (typeof offScrollEnd === 'function') {
      offScrollEnd();
    }
  };
};
var onSwipe = function onSwipe(cb) {
  return function (target) {
    var offTouchStart = on('touchstart')(function (_ref4) {
      var targetTouches = _ref4.targetTouches;
      var _targetTouches$ = targetTouches[0],
          startX = _targetTouches$.pageX,
          startY = _targetTouches$.pageY;
      var offTouchEnd = on('touchend')(function (_ref5) {
        var changedTouches = _ref5.changedTouches;
        var _changedTouches$ = changedTouches[0],
            endX = _changedTouches$.pageX,
            endY = _changedTouches$.pageY;
        var xDiff = endX - startX;
        var absXDiff = Math.abs(xDiff);
        var yDiff = endY - startY;
        var absYDiff = Math.abs(yDiff);

        if (Math.max(absXDiff, absYDiff) > 20) {
          var dir = absXDiff > absYDiff ?
          /* h */
          xDiff < 0 ? 'right' : 'left' :
          /* v */
          yDiff < 0 ? 'down' : 'up';
          cb(dir);
        }

        if (typeof offTouchEnd === 'function') {
          offTouchEnd();
        }
      })(target);
    })(target);
    return offTouchStart;
  };
};
var trackTouchesForElement = function trackTouchesForElement(el) {
  var touchIds = [];
  on('touchend')(function (_ref6) {
    var targetTouches = _ref6.targetTouches;
    touchIds = targetTouches;
  })(el);
  return function () {
    return touchIds.length;
  };
};
var trackOngoingMouseInteraction = function trackOngoingMouseInteraction(el) {
  var isInteracting = false;
  on('mousedown')(function () {
    isInteracting = true;
  })(el);
  on('mouseup')(function () {
    isInteracting = false;
  })(document.body);
  return function () {
    return isInteracting;
  };
};
var hasOngoingInteraction = function hasOngoingInteraction(el) {
  var getOngoingTouchCount = trackTouchesForElement(el);
  var getOngoingMouseClick = trackOngoingMouseInteraction(el);
  return function () {
    return !!getOngoingTouchCount() || getOngoingMouseClick();
  };
};
var fakeChild = {
  getBoundingClientRect: function getBoundingClientRect() {
    return {};
  }
};
var isWhollyInView = function isWhollyInView(parent) {
  return function () {
    var child = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : fakeChild;

    var _child$getBoundingCli = child.getBoundingClientRect(),
        cLeft = _child$getBoundingCli.left,
        cRight = _child$getBoundingCli.right;

    var _parent$getBoundingCl = parent.getBoundingClientRect(),
        pLeft = _parent$getBoundingCl.left,
        pRight = _parent$getBoundingCl.right;

    return cLeft >= pLeft && cRight <= pRight;
  };
};

var supportsPassive = function supportsPassive() {
  try {
    window.addEventListener('__rw_test__', null, {
      passive: true
    });
    window.removeEventListener('__rw_test__', null);
    return true;
  } catch (_unused) {
    return false;
  }
};

var animate = function animate(el) {
  var _ref7 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref7$delta = _ref7.delta,
      delta = _ref7$delta === void 0 ? 0 : _ref7$delta,
      _ref7$immediate = _ref7.immediate,
      immediate = _ref7$immediate === void 0 ? false : _ref7$immediate,
      _ref7$duration = _ref7.duration,
      duration = _ref7$duration === void 0 ? 500 : _ref7$duration,
      _ref7$easing = _ref7.easing,
      easing = _ref7$easing === void 0 ? easeOutQuint : _ref7$easing,
      _ref7$prop = _ref7.prop,
      prop = _ref7$prop === void 0 ? 'scrollTop' : _ref7$prop;

  return new Promise(function (res, rej) {
    if (!delta) {
      return res();
    }

    var initialVal = el[prop];

    if (immediate) {
      el[prop] = initialVal + delta;
      return res();
    }

    var hasBailed = false;

    var bail = function bail() {
      hasBailed = true;
      var pos = el[prop];
      el.removeEventListener('touchstart', bail);
      el[prop] = pos;
      return rej('Animation interrupted by interaction');
    };

    el.addEventListener('touchstart', bail, supportsPassive() ? {
      passive: true
    } : false);
    var startTime = null;

    var step = function step(timestamp) {
      if (hasBailed) {
        return;
      }

      if (!startTime) {
        startTime = timestamp;
      }

      var progressTime = timestamp - startTime;
      var progressRatio = easing(progressTime / duration);
      el[prop] = initialVal + delta * progressRatio;

      if (progressTime < duration) {
        window.requestAnimationFrame(step);
      } else {
        el[prop] = initialVal + delta; // jump to end when animation is complete. necessary at least for immediate scroll

        res();
      }
    };

    window.requestAnimationFrame(step);
  });
};

var Whirligig = /*#__PURE__*/function (_React$Component) {
  _inherits(Whirligig, _React$Component);

  var _super = _createSuper(Whirligig);

  function Whirligig(props) {
    var _this;

    _classCallCheck(this, Whirligig);

    _this = _super.call(this, props);

    _defineProperty(_assertThisInitialized(_this), "eventListeners", []);

    _defineProperty(_assertThisInitialized(_this), "isScrolling", false);

    _defineProperty(_assertThisInitialized(_this), "canSelfCorrect", function () {
      return !_this.props.preventAutoCorrect && !_this.state.isAnimating && !_this.isScrolling && !_this.isInteracting();
    });

    _defineProperty(_assertThisInitialized(_this), "shouldSelfCorrect", function () {
      return _this.props.snapToSlide && _this.canSelfCorrect();
    });

    _defineProperty(_assertThisInitialized(_this), "handleKeyUp", function (nextKeys, prevKeys) {
      return function (_ref) {
        var key = _ref.key;
        var isNext = includes(key, nextKeys);
        var isPrev = includes(key, prevKeys);

        _this.setState({
          isAnimating: true
        });

        if (isNext) {
          _this.next().catch(noop);
        }

        if (isPrev) {
          _this.prev().catch(noop);
        }

        return false;
      };
    }(_this.props.nextKeys, _this.props.prevKeys));

    _defineProperty(_assertThisInitialized(_this), "getPartiallyObscuredSlides", function () {
      var _assertThisInitialize = _assertThisInitialized(_this),
          whirligig = _assertThisInitialize.whirligig;

      var findFirstObscuredChildIndex = _toConsumableArray(whirligig.children).findIndex(function (child, i, children) {
        return !isWhollyInView(whirligig)(child) && isWhollyInView(whirligig)(children[i + 1]);
      });

      var firstObscuredChildIndex = Math.max(findFirstObscuredChildIndex, 0);

      var findLastObscuredChildIndex = _toConsumableArray(whirligig.children).findIndex(function (child, i, children) {
        return !isWhollyInView(whirligig)(child) && isWhollyInView(whirligig)(children[i - 1]);
      });

      var lastObscuredChildIndex = Math.max(findLastObscuredChildIndex, 0) || whirligig.children.length - 1;
      return [firstObscuredChildIndex, lastObscuredChildIndex];
    });

    _defineProperty(_assertThisInitialized(_this), "getNearestSlideIndex", function () {
      var _this$whirligig = _this.whirligig,
          children = _this$whirligig.children,
          scrollLeft = _this$whirligig.scrollLeft;
      var offsets = [].slice.call(children).map(function (_ref2) {
        var offsetLeft = _ref2.offsetLeft;
        return Math.abs(offsetLeft - scrollLeft);
      });
      return offsets.indexOf(Math.min.apply(Math, _toConsumableArray(offsets)));
    });

    _defineProperty(_assertThisInitialized(_this), "setWhirligigRef", function (r) {
      _this.whirligig = r;
    });

    _this.state = {
      activeIndex: props.startAt,
      isAnimating: false,
      visibleSlides: _this.props.visibleSlides || 0,
      slideBy: _this.props.slideBy || _this.props.visibleSlides || 0
    }; // We can't do arrow function properties for these since
    // we are passing them to the consuming component and we
    // require the proper context

    _this.next = _this.next.bind(_assertThisInitialized(_this));
    _this.prev = _this.prev.bind(_assertThisInitialized(_this));
    _this.slideTo = _this.slideTo.bind(_assertThisInitialized(_this));
    return _this;
  }

  _createClass(Whirligig, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this2 = this;

      this.DOMNode = findDOMNode(this.whirligig);
      this.isInteracting = hasOngoingInteraction(this.DOMNode); // These are not a part of component state since we don't want
      // incure the overhead of calling setState. They are either cached
      // values or state only the onScrollEnd callback cares about and
      // are not important to the rendering of the component.

      this.childCount = this.whirligig && this.whirligig.children ? this.whirligig.children.length : 0;
      var slideBy = {
        left: function left() {
          return -_this2.state.slideBy;
        },
        right: function right() {
          return _this2.state.slideBy;
        },
        up: function up() {
          return 0;
        },
        down: function down() {
          return 0;
        }
      };
      this.eventListeners = [].concat(_toConsumableArray(this.eventListeners), [onScrollStart(function () {
        _this2.isScrolling = true;
      }), on('touchstart')(function () {
        _this2.isScrolling = true;
      })(this.whirligig), onScrollEnd(function () {
        _this2.isScrolling = false;

        if (_this2.canSelfCorrect()) {
          if (_this2.props.snapToSlide) {
            _this2.slideTo(_this2.getNearestSlideIndex()).catch(noop);
          } else {
            _this2.props.afterSlide(_this2.getNearestSlideIndex());
          }
        }
      }, {
        target: this.DOMNode
      }), on('touchend')(function () {
        if (_this2.canSelfCorrect()) {
          _this2.props.snapToSlide ? _this2.slideTo(_this2.getNearestSlideIndex()).catch(noop) : _this2.props.afterSlide(_this2.getNearestSlideIndex());
        }
      })(this.whirligig), onSwipe(function (direction) {
        if (!_this2.props.preventSwipe && _this2.props.snapToSlide) {
          _this2.slideTo(_this2.state.activeIndex + slideBy[direction]()).catch(noop);
        }
      })(this.whirligig)]);
      this.slideTo(this.props.startAt, {
        immediate: true
      }).catch(noop);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.eventListeners.forEach(function (fn) {
        return typeof fn === 'function' && fn();
      });
    } // eslint-disable-next-line camelcase

  }, {
    key: "UNSAFE_componentWillReceiveProps",
    value: function UNSAFE_componentWillReceiveProps(_ref3) {
      var slideBy = _ref3.slideBy,
          visibleSlides = _ref3.visibleSlides;

      if (slideBy !== this.props.slideBy || visibleSlides !== this.props.visibleSlides) {
        this.setState({
          slideBy: slideBy || visibleSlides || 1
        });
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      this.childCount = this.whirligig && this.whirligig.children ? this.whirligig.children.length : 0;

      if (this.shouldSelfCorrect()) {
        var nearestSlideIndex = this.getNearestSlideIndex();
        nearestSlideIndex !== this.state.activeIndex && this.slideTo(this.getNearestSlideIndex()).catch(noop);
      }

      if (prevProps.slideTo !== this.props.slideTo) {
        this.slideTo(this.props.slideTo).catch(noop);
      }
    }
  }, {
    key: "shouldComponentUpdate",
    // isAnimating state is the only important state value to the rendering of this component
    value: function shouldComponentUpdate(nextProps, _ref4) {
      var isAnimating = _ref4.isAnimating;
      var propValues = [].concat(_toConsumableArray(values(this.props)), [this.state.isAnimating]);
      var nextPropValues = [].concat(_toConsumableArray(values(nextProps)), [isAnimating]);
      return !nextPropValues.every(function (val, i) {
        return val === propValues[i];
      });
    }
  }, {
    key: "next",
    value: function next() {
      var childCount = this.childCount,
          props = this.props,
          state = this.state;
      var activeIndex = state.activeIndex,
          slideBy = state.slideBy;
      var infinite = props.infinite;
      var firstIndex = 0;
      var lastIndex = childCount - slideBy;

      if (!slideBy) {
        var _this$getPartiallyObs = this.getPartiallyObscuredSlides(),
            _this$getPartiallyObs2 = _slicedToArray(_this$getPartiallyObs, 2),
            _ = _this$getPartiallyObs2[0],
            nextSlide = _this$getPartiallyObs2[1];

        var nextInfinteSlide = nextSlide === childCount - 1 ? 0 : nextSlide;
        return this.slideTo(infinite ? nextInfinteSlide : nextSlide);
      }

      var nextActiveCandidate = activeIndex + slideBy;
      var nextActive = Math.min(nextActiveCandidate, lastIndex);
      var nextActiveInfinite = activeIndex === lastIndex ? firstIndex : nextActive;
      return this.slideTo(infinite ? nextActiveInfinite : nextActive);
    }
  }, {
    key: "prev",
    value: function prev() {
      var childCount = this.childCount,
          state = this.state,
          props = this.props;
      var activeIndex = state.activeIndex,
          slideBy = state.slideBy;
      var infinite = props.infinite;
      var firstIndex = 0;
      var lastIndex = childCount - slideBy;

      if (!slideBy) {
        var prevSlide = Math.max(activeIndex - 1, firstIndex);
        var prevInfinteSlide = prevSlide === activeIndex ? childCount - 1 : prevSlide;
        return this.slideTo(infinite ? prevInfinteSlide : prevSlide);
      }

      var nextActive = Math.max(activeIndex - slideBy, firstIndex);
      var nextActiveInfinite = activeIndex === firstIndex ? lastIndex : nextActive;
      return this.slideTo(infinite ? nextActiveInfinite : nextActive);
    }
  }, {
    key: "slideTo",
    value: function slideTo(index) {
      var _this3 = this;

      var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref5$immediate = _ref5.immediate,
          immediate = _ref5$immediate === void 0 ? false : _ref5$immediate;

      if (this.childCount === 0) {
        return Promise.reject('No children to slide to');
      }

      if (!this.whirligig) {
        return Promise.reject('The Whirligig is not mounted');
      }

      var _this$props = this.props,
          afterSlide = _this$props.afterSlide,
          beforeSlide = _this$props.beforeSlide,
          easing = _this$props.easing,
          duration = _this$props.animationDuration,
          infinite = _this$props.infinite,
          preventScroll = _this$props.preventScroll,
          snapPositionOffset = _this$props.snapPositionOffset;
      var _this$whirligig2 = this.whirligig,
          children = _this$whirligig2.children,
          scrollLeft = _this$whirligig2.scrollLeft;
      var slideIndex = normalizeIndex(index, this.childCount, infinite);
      var startingIndex = this.state.activeIndex;
      var delta = children[slideIndex].offsetLeft - scrollLeft - snapPositionOffset;

      if (startingIndex !== slideIndex) {
        beforeSlide(index);
      }

      this.setState({
        isAnimating: true,
        activeIndex: slideIndex
      });
      return new Promise(function (res, _) {
        if (immediate) {
          _this3.whirligig.scrollLeft = children[slideIndex].offsetLeft;
          return res();
        } else {
          var originalOverflowX = preventScroll ? 'hidden' : 'auto';
          var prop = 'scrollLeft';
          return res(animate(_this3.whirligig, {
            prop: prop,
            delta: delta,
            easing: easing,
            duration: duration,
            originalOverflowX: originalOverflowX
          }));
        }
      }).then(function () {
        _this3.setState({
          isAnimating: false
        });

        if (startingIndex !== slideIndex) {
          return afterSlide(slideIndex);
        }
      }).catch(function (_) {
        _this3.setState({
          isAnimating: false
        });
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props2 = this.props,
          afterSlide = _this$props2.afterSlide,
          animationDuration = _this$props2.animationDuration,
          beforeSlide = _this$props2.beforeSlide,
          children = _this$props2.children,
          className = _this$props2.className,
          easing = _this$props2.easing,
          infinite = _this$props2.infinite,
          gutter = _this$props2.gutter,
          nextKeys = _this$props2.nextKeys,
          prevKeys = _this$props2.prevKeys,
          preventScroll = _this$props2.preventScroll,
          preventAutoCorrect = _this$props2.preventAutoCorrect,
          preventSwipe = _this$props2.preventSwipe,
          snapToSlide = _this$props2.snapToSlide,
          snapPositionOffset = _this$props2.snapPositionOffset,
          onSlideClick = _this$props2.onSlideClick,
          slideClass = _this$props2.slideClass,
          slideTo = _this$props2.slideTo,
          slideBy = _this$props2.slideBy,
          startAt = _this$props2.startAt,
          style = _this$props2.style,
          visibleSlides = _this$props2.visibleSlides,
          props = _objectWithoutProperties(_this$props2, ["afterSlide", "animationDuration", "beforeSlide", "children", "className", "easing", "infinite", "gutter", "nextKeys", "prevKeys", "preventScroll", "preventAutoCorrect", "preventSwipe", "snapToSlide", "snapPositionOffset", "onSlideClick", "slideClass", "slideTo", "slideBy", "startAt", "style", "visibleSlides"]);

      var preventScrolling = preventScroll ? 'hidden' : 'auto';
      var styles = {
        display: 'flex',
        flexFlow: 'row nowrap',
        justifyContent: 'space-between',
        overflowX: preventScrolling,
        msOverflowStyle: '-ms-autohiding-scrollbar',
        // chrome like scrollbar experience for IE/Edge
        position: 'relative',
        // makes .whirligig an offset parent
        transition: 'all .25s ease-in-quint',
        outline: 'none',
        WebkitOverflowScrolling: 'touch'
      };
      return /*#__PURE__*/createElement("div", _extends({
        className: className,
        style: _objectSpread2(_objectSpread2({}, style), styles),
        ref: this.setWhirligigRef,
        tabIndex: "0",
        onKeyUp: this.handleKeyUp,
        role: "list"
      }, props), Children.map(typeof children === 'function' ? children(this.next, this.prev) : children, function (child, i) {
        return /*#__PURE__*/createElement(Slide, {
          className: slideClass,
          key: "slide-".concat(i),
          basis: visibleSlides ? "calc((100% - (".concat(gutter, " * ").concat(visibleSlides - 1, ")) / ").concat(visibleSlides, ")") : 'auto',
          gutter: i > 0 ? gutter : '',
          onClick: onSlideClick,
          role: "listitem"
        }, child);
      }));
    }
  }]);

  return Whirligig;
}(Component);

_defineProperty(Whirligig, "defaultProps", {
  afterSlide: noop,
  animationDuration: 500,
  beforeSlide: noop,
  gutter: '1em',
  nextKeys: ['ArrowRight'],
  onSlideClick: noop,
  prevKeys: ['ArrowLeft'],
  preventAutoCorrect: false,
  preventScroll: false,
  preventSwipe: false,
  snapPositionOffset: 0,
  snapToSlide: false,
  startAt: 0,
  style: {}
});

export default Whirligig;
